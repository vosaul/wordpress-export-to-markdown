---
title: "We are teaching functional programming wrong"
date: "2020-08-03"
---

Today Richard Feldman shares his story of going from javascript developer to elm developer to functional programming teacher.  Along the way, Richard finds that people are teaching functional programming wrong.  We are teaching it in a way that misses how most industrial software developers learn best.

In this episode, Richard Feldman delves into Elm, his approach, and how to make teaching delightful.

<iframe style="border: none;" src="//html5-player.libsyn.com/embed/episode/id/15453467/height/90/theme/custom/thumbnail/yes/direction/backward/render-playlist/no/custom-color/87A93A/" width="100%" height="90" scrolling="no" allowfullscreen="allowfullscreen"></iframe>

"If you want to get a different outcome than what previous teaching methods have done. I think you need to try to do things differently." Richard Feldman

"If someone says like, “Hey, can you recommend a really good book to get into Haskell?” And if they're not a grad student, I'm like, “I really don't have any strong recommendations for you". If you want to use it at work or you want to use it to build stuff like there is not a single book on Haskell that I'm aware of \[...\] where like, Hello World is like earlier than a chapter three." Richard Feldman

"I felt like I knew everything about programming or like I knew close to enough that I was getting diminishing returns and all of a sudden I used Elm and I was like, I know nothing." Richard Feldman

"This is so much better than what I thought was available. I didn't know anything like this could exist and then that's what I wanted to do. I just wanted to build more stuff in Elm. That's kind of what I've been doing ever since." Richard Feldman

### **Transcript**

_This is a machine-translated transcript. Podcast page for [this episode is here](https://corecursive.com/teaching-fp-with-richard-feldman/)_

### **Introduction**

**Adam:** Could you state your name and what you do?

**Richard:** Sure. I'm Richard Feldman. I'm head of technology at NoRedInk. We make software for English teachers and I've been a web developer for more than a decade now, almost a decade and a half.

**Adam:** How would you describe yourself to somebody who can't see you right now?

**Richard:** I have red hair and a red beard and I don't know I guess those are my most notable distinguishing features.

**Adam:** Hello and welcome to CoRecursive, I am Adam Gordon Bell. Today, we have a fun story from Richard. It starts off when he is a Javascript developer and he starts learning about functional programming and a language called Elm. Part two though is my favorite, that's where he tries to teach the world about Elm and about functional programming and he hits some interesting problems. In fact, he thinks that people are teaching these things wrong and he has a strategy for teaching things better. Elm, by the way, is a Haskell dialect that compiles to JavaScript, but that is not how Richard would explain it. He'd explained it like this. 

**Richard:** So I'd say, yeah, it's the delightful language for making reliable web apps?

**Adam:** Why does he explain it that way? Well, we will get to that, but let's start back when he was having lunch with one of his colleagues back when he thought CoffeeScript was the coolest programming language ever. 

## **Lunch with Deech**

**Richard:** So his name's Deech (that's his nickname). I think Aditya Siram is his full name, so he gives talks about functional programming and stuff, and we happened to be coworkers at the time. I didn't know him before that, but we both lived in St.Louis. So, I kind of knew of him cause we went to the same meetups and stuff. But yeah, I mean, we were working on the same project. I was working on the front end. He was working on the backend, and we both used to go to lunch together and we talked about programming and at the time I was kind of like of the opinion. I was like, man, CoffeeScript is such a game-changer for the front end web development world because the syntax is different, you know, like, you have like, everything's an expression. Can you imagine that? so my sort of worldview is relatively small compared to what it has become since then and he really expanded my sort of horizons. Like he would talk to me about Lisp and about, like my only static typing exposure at that point had been like Java C++ and I guess that's about it, to be honest, but yeah, like Deech and I would go touch and we talk about programming and he's sort of a connoisseur of programming languages. I mean, to this day, like, I don't know anybody who has a more like encyclopedic knowledge of not just mainstream popular languages, but obscure ones too like he's given talks about, like ATS and Shen and like languages where it's not just that almost no one's heard of them, but like, he's actually like built non-trivial applications in him. He's not just, you know, talking about it. Like, he read a paper about it or something he's like actually used it and they got a building on his computer and stuff like that but, yeah, I mean, he really expanded my horizons and, and sort of convinced me that, it would be worth my time to try one of these languages out. And I really underestimated how right he was about that. I mean, it really completely changed the course of my career and my relationship with programming like

**Adam:** what did he say that like, he's like, you got to check out ATS and you're like rolled your eyes or no?

**Richard:** No. I mean, actually ATS talk is called not a taste of ATS, but a tase of ATS because it's pretty painful. He has two different talks he's given on ATS and they're both pretty funny. The strangely one, in particular, I really was in the audience, I was laughing my head off because I mean, he pokes fun at like all of the sharp edges in the language of which there are many.

## **Maybe You Should Look at Haskell**

**Adam:** So your friend Deech, he got you excited about, about I guess like Haskelly type languages. It sounds like that was that.

**Richard:** Well, there were two categories of things that he really kind of opened my eyes to. And they're arguably two different extremes although I think he would be quick to point out that these are neither of them is that extreme, he would give off a few examples of things that are more extreme in either direction but in the popular discourse, the two extremes would be Lisp on one side and Haskell on the other, Haskell being very much about doing things at compile-time and Lisp being very much about doing things at runtime, I guess, other than macros, those are the things that Lisp does it compile time.

But yeah, he opened my eyes to sort of both of those and like the idea that you could have languages that were a lot simpler than like, at the time I'd done like Java, Javascript, C, C++, Pearl and CoffeeScript and like way back in the day, like Basic and Visual Basic. So those, whatever that is half dozen or so languages were sort of my main exposure to like the range of programming languages like Lisp is just a way simpler language then. I mean, like fundamentally more than any of those languages and half is a way more complicated language than all of those except maybe C++.

## **Writing a Novel**

**Adam:** In this time period, when Richard was working with Deech and talking to them about programming languages, he was also working on writing his own fantasy novel. 

**Richard:** So I've been kind of casually into fiction writing for a long time, probably since before high school even and at some point, I decided that I was going to write a novel. And so I went out and looked at all the different novel writing software out there and I tried a few different things and none of them really fit with the way that I wanted to do it, which was kind of like I wanted to write one long continuous document, but I also wanted it to be structured in a sort of chapter centric way like there were certain things I wanted to know about each chapter, like how many words per chapter and like which characters appear to which chapters and things like that and I couldn't find something that was all of those.

Everything was either too structured, you had to edit only one chapter at a time and you couldn't see the flow of how things transitioned between chapters or they weren't chapter-centric enough and so, being a program right. Decided to scratch my own itch. Being a web developer I naturally gravitated towards building it in the browser and I made the first version in JavaScript and used it and I wrote quite a lot of words in it, tens of thousands of words and I kept adding features and tweaking it and eventually it got to the point where it was unmaintainable anymore. The straw that broke the camel's back, as I recall, was that I broke paste somehow, paste wasn't working anymore, just copying and pasting and the way that I would work around this was if I wanted to copy and paste something, I would just go to go into inspect element and like copy out of the Dom and then paste it somewhere else in the Dom or chunks of HTML, move them around, inside the content editable, which, you know, was no way to live.

I couldn't figure it out, I didn't want to go back to before. I chose the regression because I couldn't, I also didn't want to live without the features that I built that caused their regression. So I know at some point I'm going to have to rewrite this thing because it just became too much of a disaster.

## **Thinking About The Rewrite**

**Adam:** Do you see where this is going? So Deech is telling (Richard). Haskell is awesome. Lisp is awesome. ATS is crazy. I don't know, Deech is just selling him all the beauty of these different programming languages and then Richard is working on his writing app and it's just falling apart. So obviously he decides, “Hey, maybe I should try something Haskell-y for every right?”

**Richard:** I was convinced that I wanted to try it, but I didn't want to literally try Haskell because you can't really build UIs with Haskell proper, and building UIs is what I really like to do. So, I was really hoping for a language that I could use in the browser to build UIs, but still those like a pure functional language with type inference and all that.

So, at first, I thought that language was a way to be Roy, which was the language that Brian McKenna made but he got stuck partway through making the compiler and he ended up not finishing it. I was sad about that because who knows when something else is going to come along, so I actually got really excited about the pure script because pure script also checked all those boxes. 

The one thing that it didn't have that kind of kept me from trying it out was, it didn't have a virtual dom. So, between when Roy came out and when I was looking to rewrite, the dream writer React came out and I started using it and I got really into it and really liked it and I really was like this is a deal-breaker for me. I got to have a virtual dom and at the time Pure Script didn't yet have one. There was one project, people were working on React bindings, and I was cheerleading in the comments. So I don't know anything about this language, but I really hope to get these bindings working so I can use them.

And I've learned the language and while waiting for that this blog post came out, that was a blazing, fast HTML in Elm. And it was basically announcing not only does Elm now have a virtual Dom, meaning it checked absolutely all my boxes, but also there were benchmarks showing it's actually quite a bit faster than most of the leading alternatives at the time, like React, Angular and Amber and all that.

So, I just sort of was like, “Wow! this is everything that I was looking for. I guess now I'm going to learn this and try to figure it out.” So what I did was I started my rewrite of a dream writer. Then I took the MBC example for Elm, and I just tried to figure out how to use the language and build it up from scratch and so I ended up rebuilding a dream writer to do MBC basically from scratch and I never quite got it to feature parody, but I got to the point where I switched over to using it because it was so much less buggy and actually it wasn't buggy at all at the new version, just everything kind of worked and it was great. And I wrote probably around 60,000 words in that before my novel ended up getting derailed by just getting so into Elm, I started spending all my free time doing Elm things instead of writing fiction.

**Adam:** Did you finish your book?

**Richard:** No, I still have it and one of my friends is still waiting for it. He's like, “Hey, yeah, you're finishing it?” I'm like, “No, no” because I've been sending him chapters along the way and he really liked the story. But, it's hard. I mean, I just fell so fully in love with Elm that I just started spending absolutely all of my free time just doing Elm things and never looked back.

## **The Elm Rewrite of Dream Writer**

**Adam:** So what happened? You have your dream writer and you start rewriting it. Did you just take a weekend and you started just trying to pull out parts and try them out and Elm or what was the experience like?

**Richard:** That would have been smarter. The smart way to do it is incremental. But that was not what I did. What I did was I just started with ToDoMVC and just started adding onto it, to add a text, editing and add this and that until it and add CSS.

I did keep my style sheets because I had them all in a separate style sheet. So I ported that over directly but all of the logic and all the rendering, I just rewrote from scratch, from the ground up and didn't keep any of the old stuff. So at first, it was, it was not just one week, it took a while before it was back up to the point where I could use it as my primary fiction writing thing again.

It was really nice, it was a good experience, although it definitely would have been faster and I would have been able to have something usable sooner if I'd done it more incrementally. I just, “Hey, that didn't occur to me at the time.” I didn't really know that it was going to be faster because I hadn't had any experience with Elm yet.

I mean, not there weren't many people using it back then. Like in those days there was one Elm meetup, which was the San Francisco Elm meetup and by sheer coincidence, I happened to be living in San Francisco at the time. and I went to it, and there were like 15 people there and so very small community at the time. Wasn't a lot of like, -- Hey, how do you know, get advice on how to use element work? Whereas now you just hop on Elvis Slack. It's like, you know, 20 people immediately respond like, “Oh, here's how to use element work” And the advice they'll probably give you is to introduce it incrementally.

**Adam:** Yeah, I can see why that would be more palatable. I imagine like because I've taken a side project and tried to redo it before and gotten like partway through, any other regretted my decisions or abandoned things like, did you have moments of questioning your decision?

**Richard:** I have on other projects, but not on this one. I mean, I was just having so much fun. I didn't. I mean, as I said, I just stopped wanting to do other things because it was just so much fun to build more stuff in Elm. I've been programming since I was nine and it just never, nothing has felt like this since like, when I was 10, I got Visual Basic and I could make UIs and I was like, “Whoa! this is such a game-changer.” Then it was like another, you know, almost two decades of C++ and Java and whatnot and everything. I felt like I knew everything about programming or as I knew close to enough that I was getting diminishing returns and all of a sudden I used Elm and I was like, I know nothing. This is so much better than what I thought was available. I didn't know anything like this could exist and then that's what I wanted to do. I just wanted to build more stuff in Elm. That's kind of what I've been doing ever since. 

## **Everything was Different**

**Richard:** I can tell you, the confidence I had in changing my Java codebase compared to my old codebase, it's almost like Java might as well dynamically typed. I mean, for the amount of help that I'm getting relative to what I experienced at Elm.

I mean, it was just totally night and day different. I completely and I thought going in, that the type inference was going to be a big difference. I thought that it was going to be like, “Oh, this will be like Java, but without all the ceremony” And it was, but it turned out that that was such a small benefit compared to the real big benefit, which was -- what if the APIs and the compiler are in cahoots to make an amazing refactoring and maintenance experience, like nothing you've ever had before. That was the real benefit, but I had no idea that's what it was going to be coming in. I mean, other than hints I got from talking to Deech like, I didn't know what that was like until I had sort of felt it and then everything was different.

## **Elm At Work**

**Adam:** Did you like to go into work and find a Deechor start telling people about how great this was?

**Richard:** So at that point, I actually worked at a different company. I worked with Deech in St. Louis, but this was in San Francisco. I had a new set of coworkers and I did talk to them about it, but it was quite a while before I actually introduced myself to it at work, because I felt that, I just thought it was too risky. We were a small startup and I was like, well, this is an unproven technology, you know? I mean, I've sort of proven that it's great for my side project, but that's not the same thing as, you know, being usable at work but, eventually we got to a point where, there was one particular project that we worked on at work where it took several months to complete and a large part of that was because we kept having to make major design changes to it based on user feedback.

Like we make a version, take it out, test it out on it. These were students -- we were trying to teach middle schoolers how to do active voice and passive voice was a hard concept, even for adults and so we kept taking it out a prototype and trying it out on them and then just watching a total flop and they weren't getting it.

And then we'd go back, it's like, we care about efficacy and actually like teaching kids concepts. These days it's a lot more writing concepts than grammar like that one was. But, is like, getting real feedback is important to us. I basically had the experience of, this is like, you know, react to at the time of, I would come back and be okay, we need to make these major design decisions.

All of my tests are invalidated by the new design. What can I do to get it back in a working state? And after having gone through a couple of these, I was like, - Wow! you know, when I would make major changes to dream writer, like even bigger ones than this, I would just change, change, change, change, and then just follow the compiler error messages until everything worked again.

And then as soon as it compiled it pretty much always just, immediately worked and so like comparing those two experiences at some point, I was like, you know, if I could go back in time and like to introduce element work, it would have paid for itself on this project alone then like all future projects would be easier to maintain. So I was like, I think I was just too risk-averse. I think I missed an opportunity to use something that I knew was better, because I was like, afraid to commit, I guess so I was like, let's not do that again and let's actually use it on our next project.

## **Doubts About Elm**

**Adam:** I like what Richard said  “Hey, let's use this on our next project.” Richard is certain, that Elm is revolutionary and it's going to change the world and it's since become popular. But at that time, basically, nobody was using it and he was going to use it for their front end of their commercial startup project. I guess I would always be worried. Like if I championed something and it seems a little obscure that we'll hit some limitation I wasn't aware of and we'll be like, “Oh God, what did I do?”

**Richard:** Yeah. I mean, that's definitely a valid concern. Elm has JavaScript to interrupt so there's always that sort of fallback if something's really not working, it's not like, “well, there goes the whole project.” It's like, well, okay, we'd have to introduce a little workaround here in JavaScript. But it has occasionally happened that we like needing to dip into JavaScript for one thing or another. Actually rich text editing is a good example of that. We use Quill.js or something, which is like a really, fully-featured rich text editor for some stuff at work. I was a little bit worried about that, but I kind of figured worst comes to worst,  we can interrupt like the old way of doing things and that'll be fine.

## **Advocating For Elm**

**Adam:** Richard's committed to bringing Elm to work, but like JavaScript is JavaScript and everybody knows it where Elm is like a purely functional programming language that's case sensitive. And you know, it's based on high school, which is famously confusing to learn. Unless my front end developers were also like PL post-grads. I don't think I would just assume that they would jump in and be fine and you know, even be faster than they were one of his JavaScript.

So you were motivated to learn this, but once you like to get people at your company on board, was that more of a challenge?

**Richard:** At the time, there were two things that I had going for me that made it easier to adopt Elm. And by the way, like most people, today have an easier time adopting Elm than I did back then because the community is much bigger. It's way more battle-tested, it's actually pretty stable at this point, too. So you can just look around at all the existing success stories and be like, well, let's just do what they did. But back then, there was like one company that I knew of that was using it in a production Circuit Hub and Prezi was thinking about it, the team was pretty small. That was one thing I had going for me. There were only two people who are working on the front end and I was one of them and the other one was, it was his first programming job, out of a boot camp so he wasn't really gonna push back on my front end architectural decisions.

The other people at the company knew like they understood that this was kind of a risk, but, you know, I was obviously going to be sort of taking responsibility for it so if it didn't work out, you know, they kind of trusted me to, you know, deal with the consequences of that. But the other thing was that I had a lot of credibility because, the only other one time that I'd really strongly recommended and advocated for our front end technology.

It was React because React came out while I was working at that company and I tried it out and I was like, this is great. This is going to be really big, we should start using this and even this is, I don't know, maybe a year and change after React come out soon, less than two years after React came out, that I was advocating for Elm. But it was pretty clear that React was a good choice. It had moved the needle positively for us. This was way before React sort of took over the front end world. To this day, I maintain that for me personally, I think there were three big milestones in the frontend, web development number one was jQuery. Number two was React and number three was Elm and I think everything else in between is just almost, it's just, it's kind of noise compared to those, at least for me and I think those three are not the same in magnitude, because I think the gap between jQuery and React is smaller than the gap between React and Elm.

## **Teaching Haskell Wrong**

**Adam:** So pure functional programming according to Richard -- it's revolutionary. Elm, is the biggest breakthrough in front end programming since ever if I understand him, if this pure functional programming style is so powerful. Why isn't it more popular? The reason Richard says is people are just teaching it wrong. 

**Richard:** I think there's a really big gap in how effectively Haskell is taught versus how Java is taught and to be on the nose about it. I think that the way that people teach Haskell is, basically, extremely focused on being able to teach like very motivated graduate students and if you're not a very motivated graduate student, you have basically no one who is interested in teaching you a Haskell, or at least there, there is no material out there. And when I say no, I mean, like we started using it at work and we looked for it and we couldn't really find any like really commendable material that's like for the audience of someone who wants to use Haskell at work, I mean, none and at least from my perspective as like someone who's spent probably over a thousand hours at this point, like teaching specifically pure functional programming in the form of Elm granted. There's a lot of overlap in the concepts that I know like I've tried different ways of teaching that I've learned some that have worked and have not worked,

**Adam:** Like there are Haskell books, I know, there are lots of Haskell books.

**Richard:** There are, yeah and yet when people ask me for haskell book recommendations, I have like, basically I say like, if someone says like, “Hey, can you recommend a really good book to get into Haskell?” And if they're not a grad student, I'm like, “I really don't have any strong recommendations for you". If you want to use it at work or you want to use it to build stuff like there is not a single book on Haskell that I'm aware of and again, as I said, I've looked, and I know people who have looked, that's like build a thing in Haskell where like, Hello World is like earlier than a chapter, I'm going to say chapter three, but I usually like Hello Worlds around like chapter seven. Like that's the norm, you know? Because printing to the console is IO and the way that the Haskell books are laid out is, you talk about monads and monologues and Funkster's before you get into IO and you don't have to, but that's how they're all taught.

Like Elm has exactly the same restrictions where it's a pure language. There's, you know, the side effects are managed, and yet chapter two of _Elm In Action_ is to build an entire working page, like build a whole interactive website, because you can do that. You can teach it that way. There's absolutely like chapter one is basic syntax and chapter two is like building a whole working interactive thing and then I teach the rest of the language from there is no reason whatsoever that you could not teach Haskell exactly the same way. Chapter one: basic syntax, chapter two: build an interactive thing that works and uses effects but again, it's culturally just not done that way and in my mind, I think that's a major part of the reason that specifically pure functional programming is not as popular as it is today is that it's just inaccessible to a lot of people. I mean I personally tried to get into it - Haskell that way and ultimately the way that I got into Haskell was just, I mastered Elm first. And then after I had already mastered Elm, Haskell was, you know, there was like, just a Delta of like things I didn't know. And I was able to learn those, having already learned sort of the fundamentals of pure functional programming, the easy way through Elm and then not as intimidating.

## **Talks Can Lead You Astray**

**Adam:** Tell me why you think that people are teaching these concepts, like pure functional programming wrong.

**Richard:** So I don't want to say that they're teaching it wrong. I think it's more that they're reaching for a particular audience. And I don't know if that's intentional, but I think that I mean when I look at who we're the people who tend to be successful at learning and trying out Haskell and they pretty much fall into two groups. One group is people who are unbelievably determined and they just keep banging their head against the wall and making a little bit of progress and then eventually they grind it out and they are able to build something, really without a whole lot of help from teachers or from books. I mean like, yes, definitely some like introductory material, but like, there's very few people who are like, "Oh yeah, I just, I read about I'm going to have transformers and I got it and then I just used them" you know, like you don't hear that it's really, they just like, there was a long grind and then eventually they got there but the other group of people is like I said, graduate students. I mean, people who are used to reading academic papers and, like a lot of papers and, you know, understanding them and are familiar with a lot of terminologies that people who primarily do programming work in the industry are not familiar with and also, there's a particular way of instruction. The way I like to think of it is like, let's say I give a talk to a room full of people at a conference and at the end of the talk, I mean, I've done this many times. I've lost count of how many conference talks I've given at this point. At the end of the talk, some numbers, some small percentage of the audience will come up to me and say, “Oh, thanks, I really liked your talk.” And, and I'll say, “Oh, thank you.” And I really appreciate it when people do that and then they'll maybe ask me some questions about it and everybody else in the room will walk out of the room because they're done with the talk they're moving on to the next talk. So I don't get any feedback about what percentage of the audience understood anything. I just said. I mean, I have no idea if, if it just bounced off of everyone, all I hear is, “Hey, nice talk.” So, based on that as a teacher. If I'm teaching a workshop, it's different. If I'm teaching a workshop, I like going around and seeing what questions people have as they go through the exercises. There are certain questions I'm like, “Oh, you're really stuck. you’re not getting this at all.” versus other questions where it's like, “Oh, you, the fact that you're asking this question means that you understood it at an even deeper level because I didn't tell you the thing that would lead you to, you know, know the answer to that.” By the fact that you're asking means that you absorbed what I've talked about so far. So I don't know how someone writing a book about Haskell would like to get that feedback. So when I say, like, I think there are two groups, it's based on I'm filtering for the success stories. I hear, like, I look at like, who's in the Haskell community, who are the people who said I learned Haskell and how did they say they learned it? And one group is the people who went through a grind and just like push through it and the other group is people who had a background in like, graduate-level, computer science. and there is not really a third group. That's like, I used Python before this, and then I learned Haskell and it was fine. You know, I learned, I knew JavaScript. I went to Haskell went to Java which was no big deal. It's always a big deal and so, my sort of like proof of like this being the de facto audience for the instruction is just, that's the group that successfully learns from that instruction period. That's, that's the whole, that's the entirety of that group everybody else struggles through it, on their own somehow. And it sounds like that's how you did, like, it sounds like you're in the nongraduate student group. That sounds like your story.

**Adam:** Yeah, well, I mean, and also I'm not programming Haskell for my day job. Like that was just an experience I had where I grounded out. Yeah. Probably bounced out around somewhere around monad transformers and which was the corrector in fashion way to do it. 

## **Types and Stuff**

**Richard:** Bringing it back to your original question. I don't want to like point fingers and say that it's being taught wrong. I think that's like the natural way that it would be taught because that's, that's it's the origin story. That's where it comes from. It was, it was built by academics for academics. So why, how could it not have an academic focus and like the culture and how it's taught? Really the kind of weird thing is that it's being used in the industry despite that very intentional academic focus and so when I say that, I can't find materials that are geared towards learning it as a, as someone who is a professional programmer and not with no academic interests. Really. I don't mean to say that I, like Haskell, should feel bad about that. Or like the Haskell community is like, you know, wrong for not having produced this magical book that would be convenient for me at work but rather to say that, you know, just to make an observation that like, that's what the status quo is. And I think that when people express, like ask the question, why isn't Haskell used by more people, even though it has all these benefits? I think that's probably the biggest reason honestly, is just that the teaching materials are all historically so geared toward an academic audience, even if they don't say they are like, I mean, if you look at who succeeds in getting through them, it's an academic audience primarily and people in industries tend to struggle through it at best.

**Adam:** I mean, I would characterize things stronger than what you said. I mean like, cause people to learn the language and they get excited about it. They immediately move to step two, which is like advocating for it and right. Writing tutorials and whatever. And if people are bouncing off of those, I mean, they've failed to a certain extent.

**Richard**: I think, teaching is hard. I mean, at least that's been my experience with it. I had a lot of hypotheses about the best way to teach Elm. I mean, I was very surprised when I started teaching workshops at what things people got stuck on. and I had to like, just learn differently and experiment with different ways of teaching it before I found out what stuck and if I hadn't had that feedback loop of actually being able to try stuff out on real students and then see how it worked for them, and then iterate with a fresh batch of students who were also coming in from scratch. The reason I was able to do that was, so, I agreed to do a workshop on Elm for front end masters and Mark who runs in front of masters recommended -- we've seen people who do this work, do these workshops. you can really tell the level of like polished and quality, the difference between people who have done like only. One run through versus upwards of five, run-throughs like ahead of time of like doing the whole course. This is going to be a two-day course, like eight hours each day. And so, what I did was I went to local boot camps and I said, “Hey, I will teach your students a free learn Elm workshop, you know, over this weekend, if you want, just, just give me a room at a projector and I'll just do that.” And they can just have that. If anyone wants and I did this, I think I did it six times, actually, six or seven, before in front of masters, then I did frontend masters, and then I revised the material and then did front end masters again, two years later, after doing more dry runs of the new material and I did an advanced course and did the workshop at other conferences as well and so at this point, I mean I've revised the material a lot and learned a lot about a lot of those things. And if I were to imagine like, knowing what I know about. And again, this is like pure functional programming, which is not, what's taught in schools and it's not what sort of boot camp.

So it's not like you can just, there's not a playbook for how to do that. So I, as I said, I mean, I want to be very careful to not say like people in the Haskell community are messing up or like, or, or are, doing a bad job. But I, do think, I mean I agree with you that there's a gap between maybe like expectations, in reality, they're like, I think people say, look, what, how many Haskell look at the number of Haskell books? There are, clearly the problem is not education, but I would say like, I mean, yes, look at the number of high school books there are, but they're all written in like variations on the same way, which is, you know, I mean, like one of the really popular ones, chapter one is not like, like Elm In Action.

Chapter one: syntax chapters do build a whole interactive application chapter. One of those books is Lambda Calculus and that's like, one of the most recommended Haskell books so, I mean, You can say like, that's, you know you can say whatever you want about that but like if chapter one is Lambda calculus then, and do you think that your audience is industrial programmers? I mean, something has gone wrong so clearly the audience is intentionally going to be people who are academic or at least academically-minded and how they're going to approach learning the language.

There are lots of success stories with Haskell. I mean, like it, there are lots of people who learn it and use it in grad school or even in undergrad or even who don't have a computer science degree and just like learned it because they were interested in it. but I bet you, if you try to find people who successfully learn Haskell and, read fewer than one academic paper per month on average, it's, it's not going to be people who just like read a book and learn it that way, is going to be a lot more struggling and trying to build things and having a tough time of it but being determined to persevere through that anyway,

**Adam:** No, I think it's a great point and it feels like the meta lesson that I take away is like, “Hey, like test your stuff.” Right? Like, get out there, get exposure, to like your learning approach.

**Richard:** I honestly feel pretty lucky that I happened to be living in San Francisco and there were these boot camps and there was an interest on the part of their students to learn Elm on the weekends, you know, for free, I honestly don't know. Like I want to know that I say that I bet that would work for Haskell too. Like if you were in a city with a lot of boot camps, so like San Francisco, New York, that probably works fine. I mean, not right now during the pandemic, but you know, in a normal year, I bet that that could possibly work but definitely, iteration, is important I think, to be able to improve it that and I think also recognizing that, If you want to get a different outcome than what previous teaching methods have done. I think you need to try to do things differently.

## **How Do You Teach Differently**

**Adam:** If the rule, so the meta-rule is like to test out your, your learnings, but like we like, what did you actually learn in teaching these thin, how did that change -- how you teach?

**Richard:** Yeah, totally. Also, the most surprising thing was actually around syntax so Elm syntax is overall pretty similar to Python syntax. It's almost identical to Haskell syntax actually but the big difference is that when you call a function, like in C for example, you say function, name, ( arguments, separated by commas ). I'm very familiar with that with a lot of people in Elm, it's actually more like a CoffeeScript in that you. It's function name, space arguments, and the arguments are not separated by commas. so there's strictly less than texts there in the sense of it's just like spaces. Everything's separated by white space, it's kind of like enlist the difference is, that if you do a nested function call, in like, for example, JavaScript you don't learn any new rules. The rule that you just learned is like, you know, just do the same thing, just call the function.. but, because an Elm and Haskell that would be ambiguous, like since they're all spaced separated, you wouldn't be able to tell where one function called began and the next one ended or vice versa. So what you do is you, you introduce parentheses kind of the same way that you would in like a nested, math expression, or you put parentheses around the entire nested function call. people aren't used to that in a lot of cases if they come from like a C syntax language.

What I would see is that students would attempt to put the parentheses where they are used to them going like. Touching the function, like immediately after the function name, but that's actually a different grouping than what you want. So they get compiler errors and they wouldn't understand why they were seeing it, because they'd be like, "wait, why is this so off?" Because usually, the only thing that I've found in teaching elements that the compiler helps out a lot and like, cause it gives very even spent a lot of time like making the error message is really helpful. and so a lot of my revisions to the course material were like, I actually don't need to spend time teaching this because if I don't mention it, the subset of the class, that's going to stumble over that the compiler will tell them exactly what the problem is and explain what they should have done and then they'll just learn it that way, so trying to condense the material and like, there was a lot of time that I spent trying to eliminate things that I was saying out loud. So that, basically students could have, like less mental bandwidth thinking about edge cases and more just like letting the big concepts sink in so I guess that was, that was kind of maybe my biggest macro-level takeaway. Like the parentheses is maybe the most micro one, but the biggest macro one I think was, was trying to intentionally remove things from the curriculum and like, not to mention edge cases out loud, if they weren't important to what they were going to learn to just basically like have faith in that what I'm teaching them, whatever the scope of that is, whether it's a workshop or a blog post or a book, this is not going to be the end of their learning journey and just have faith that like they're going to, they don't need to learn about every single detail right now, quite the opposite.

They mainly need to learn enough to make it through there, what they're learning right now so that they don't get blocked and are able to move on to sort of the next phase of their learning and realizing that it's totally fine. If some, and in fact, a lot of their learning happens outside of the scope of what I'm doing and trying to like manage my scope accordingly.

## **Sequence and Scope**

**Richard:** And all of the learning stuff I've taught I've, I've tried to pair down the scope to like say, okay, what's the goal? There's a term I learned at work because we make software for teachers, a **scope** and **sequence**. It's like what is the set of things that you want the student to be able to walk away knowing like what they should be able to do? Like we say, finish the sentence, like after this book or after this workshop, students will be able to... and then work backward from there to figure out, okay, what is the list of things they need to learn?

And in what order should I teach them so that they're learning things that build on what they just learned rather than. You're like, okay, you're going to learn this and then we're not going to use it for another three chapters, but, you know, remember it for them because of course, they won't remember. I try to teach it like right before they're about to use it.

## **The Book**

**Adam: ** So you do this workshop, teach people Elm, you have this new pedagogical approach. That's kind of crazy, like build things, which doesn't sound crazy.

**Richard:** I wouldn't call it crazy. I mean, it's unusual within the realm of pure functional programming, but it's the norm everywhere else.

**Adam:** So how did you get into writing a book? I have your book here by the way.

**Richard:** Nice! There it is. I mean, someone at Manning reached out to me, so I was at that point, one of the few members of the elder community who had given any talks about it, I think I had given a talk at a strange loop at that point. Although I forget that may have been before the strange we've talked to be honest, when they reached out, I gave a talk at a meetup about a dream writer.

That was the first talk I ever gave and it was recorded and it was on YouTube and it got shared around a little bit. so I don't remember what the exact chronology when they reached out, but basically they were like, Hey, we've decided we're gonna do a book on Elm. and we're looking for authors. So, it wasn't so much that I had decided I wanted to write a book, but rather, I mean, I obviously like with fiction writing, I had done a lot of writing in the past. I have done a lot of nonfiction writing too. I actually used to write, I had a weekly column for Magic the Gathering strategy website back in the day, back in college I had some experience. I knew that I was capable, of writing both long-form stuff from, you know, writing all this, all the novels at that point. and writing nonfiction from these strategy articles but I'd never tried, you know, writing a whole book about programming. I'd only at most written blog posts.

But basically what happened was, when this guy, Mike, it was like, “Hey, I want to do a book about Elm. Can you hop on a call?” and we'll talk about it. You know, potential authors. I was like, “Sure.” So here are the people in the Elm community I could recommend and at some point, I was like, I don't remember if he asked me, I think I just started volunteering this, but I was like, by the way, I think if you're going to do a book on the element's really important that... 

I basically said a lot of the stuff we just talked about, like it should be, you know, about building stuff. It should not be about theory. There are a million books on pure FP that are theory, there is basically none that are focused on building stuff you know, and I also, I had some other opinions about like in particular, this may be culturally changing, but at the time.

Everybody in the front end community was doing JavaScript and was doing it dynamically typed. TypeScript was, I mean, this was 2015, so TypeScript was, it existed? but it was just, it was nothing. I mean it was probably about the sciences at Elm to be perfectly honest at that time despite the fact that the learning curve was basically zero, it was backed by Microsoft, but at that time, Microsoft primarily VS code didn't exist yet either. I don't think at that time, Microsoft was primarily known as the Internet Explorer company. So the idea of like, you know,

**Adam:** Front end devs weren't signing up...

**Richard:**...Which is a wild idea like if you, I mean, over the course of five years, they went from being the Internet Explorer company, just reviled by front end developers everywhere because they have to do all the most painful cross-browser testing on their platform to the company that owns GitHub and provides VS codes and TypeScripts. Like, wow, what are the odds that those that are quite 180. but, so at the time, basically like part of teaching Elm was reassuring people that doing type checking was going to be okay and it wasn't going to be like Java. so I very intentionally, like I don't introduce types until chapter three, like chapter one, you learn the syntax and, you know, basic constructs, if and whatnot chapter two, you build a thing and then chapter three, you add types, you learn about types and you add the type annotations to certain parts of what you built in chapter two. So actually the type inference turned out to be very useful from an educational perspective because it let me get through chapter two where you, you build a thing from start to finish without even mentioning types, let alone writing any, like, you don't even have the syntax for them at that point.

**Adam:** Yeah, I think I actually noted this down. So I feel like you tried to sneak it in like it was tables or something because when you introduce types you introduce it as a form of documentation. You're like, “Oh maybe, maybe we should just say what type this is so that we know when we look back.”

**Richard:** Yeah. Exactly. I was kind of pitching it as like, you know, here's the advantage that type annotations have over comments. Like they don't get stale, like comments can, you know, document and lie. I was basically trying to motivate, why are we going to go through and bother adding typing annotations to code that already works?

## **Teaching Motivations**

**Adam:** This term motivate it kind of made a light bulb go off for me. Like maybe that's, what's lacking from some approach to teaching things. We kinda throw concepts that people. And we don't spend time explaining to them, like why they should care. I think it also kind of explains how Richard described Elm. Right? He didn't categorize it as saying it was a functional programming language or blah blah blah...

He said something like it's a delightful language for building web apps. He was kind of describing why you would want to use it, you'd want to use it cause it's delightful. Rather than because it's a Haskell dialect.

And I think also his project-based approach where you're like trying to build something and then you encounter a problem. And then, you know, that is used to motivate the next concept you have to learn, its also part of the secret of his approach. I still, okay. I still feel like, like you skipped this part and maybe cause it's, maybe I'm just projecting this onto you. Maybe it's not the case but, as you said, there were these Haskell resources, which you found not helpful and then you, like, they didn't fit who you are or however you want to characterize it, but then your book is all about building something and like, I don't think that's the case, necessarily of like other like pedagogical approaches to functional programming. So, like, is that the key here? Is that the key to your teaching experience? Or could you have done this just as well with doing small examples that never really build?

**Richard:** One of the things that were similarly important to me about this book was that, so the title of the book is _Elm in Action_ and it's Manning and Manning does a lot of inaction books. That's like one of their series is, they also have books like, in practice, which is sort of like, Oh, this is a thing that's like, you know, and actually like you hear about like, real-world Haskell or real-world OCaml, books where the title itself implies that. You know what, this is not normal, what you're doing, like using Haskell in the real world. That's not the norm. This is a book for the weird subset of people who are using Haskell for real things. Right. I mean,, that is kind of the implication of the title. Like, imagine a book with Real-World JavaScript, like what?! I mean, that's, you know, of course, that's the default, you use it in the real world to build stuff and so I really wanted to make sure that like, it was clear right from the title. Like this is a book for building stuff I'll put it this way. I think if someone were to write a book about Haskell where the way that they taught Haskell was step one, here's how to build a thing. And then I'm going to fill in the gaps in the theory after you've built a thing.

I think there would be a lot of interest in a lot of demand for a book like that. I think there's a lot of people who learn effectively that way, who are not being served right now in the world of like, they have an interest in learning Haskell. They've heard a lot of things about Haskell they're motivated to try learning that way and they would be able to learn effectively that way, but that book doesn't  exist as far as I know,

**Adam:** All right. That was the show. If you agree with Richard's approach to teaching, let me know on Twitter. If you disagree, you know, let me know on Twitter as well, or however, you communicate. I have a couple of ebook copies of his book to give away to people, who engage with me. So I'll probably do some sort of raffle.

Until next time. Thank you so much for listening.
